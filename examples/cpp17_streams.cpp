/* Copyright (c) 2018-2022 Marcelo Zimbres Silva (mzimbres@gmail.com)
 *
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE.txt)
 */

#include <iostream>
#include <memory>
#include <boost/asio.hpp>
#include <boost/redis.hpp>
#include <boost/redis/src.hpp>

#include <memory>
#include <string>
#include <thread>
#include <vector>
#include <chrono>

namespace net = boost::asio;

namespace redis = boost::redis;
using redis::operation;
using redis::request;
using redis::generic_response;

void log(boost::system::error_code const& ec, char const* prefix)
{
   std::clog << prefix << ec.message() << std::endl;
}

class redis_client: public std::enable_shared_from_this<redis_client> {
private:
   redis::connection conn_;
   redis::address addr_;
   std::string redisStreamKey_;
   std::string streamId_;
   redis::request req_;
   redis::generic_response resp_;

public:
    redis_client(
       net::io_context& ioc, redis::address const& addr, const std::string& redisStreamKey)
        : conn_(net::make_strand(ioc))
        , addr_{addr}
        , redisStreamKey_(redisStreamKey)
        , streamId_("$")
    {
    }

    void start()
    {
       std::chrono::seconds timeout{10};

       auto self = shared_from_this();

       redis::async_run(conn_, addr_, timeout, timeout, [self](auto ec) {
          log(ec, "async_run: ");
       });

       do_exec();
    }

private:

    void do_exec()
    {
        req_.clear();
        req_.push("XREAD", "BLOCK", "0", "STREAMS", this->redisStreamKey_, this->streamId_);
        auto self = shared_from_this();
        conn_.async_exec(req_, resp_, [self](auto ec, auto size) { self->on_exec(ec, size); });
    }

    void on_exec(boost::system::error_code ec, std::size_t)
    {
        on_exec_internal(ec);
        do_exec();
    }

    void on_exec_internal(boost::system::error_code ec)
    {
        try {
           static const std::string Response_Field_MyField = "myfield";

           if (ec) {
               log(ec, "on_exec: ");
               conn_.cancel(operation::run);
               return;
           }

           if (!resp_.has_value()) {
               return;
           }

           // std::cout << "Response: ";
           // for (int i = 0; i < resp_.value().size(); ++i) {
           //     std::cout << resp_.value().at(i).value << ", ";
           // }
           // std::cout << std::endl;

           // The following approach was taken in order to be able to deal with the responses,
           //  as generated by redis in the case that there are multiple stream 'records' within a single generic_response.
           //  The nesting and number of values in localResp->value() are different, depending on the contents of the stream in redis.
           //  Uncomment the above commented-out code for examples while running the XADD command.

           // "myfield" values don't start before index 4.
           std::size_t itemIndex = 4;
           while (itemIndex < resp_.value().size()) {
               const auto& val = resp_.value().at(itemIndex).value;

               if (Response_Field_MyField.compare(val) == 0) {
                   // We've hit a myfield field.
                   //  The streamId is located at itemIndex - 2
                   //  The payload is located at itemIndex + 1
                   this->streamId_ = resp_.value().at(itemIndex - 2).value;
                   std::cout << "[" << std::this_thread::get_id() << "] StreamId: " << this->streamId_ << ", MyField: " << resp_.value().at(itemIndex + 1).value << std::endl;
                   ++itemIndex; // We can increase so we don't read this again
               }

               ++itemIndex;
           }
        } catch (...) {
        }
    }
};

// Run this in another terminal:
//  redis-cli -r 100000 -i 0.0001 XADD "test-topic" "*" "myfield" "myfieldvalue1"
auto main(int argc, char * argv[]) -> int
{
    try {
        std::string redisHost = "127.0.0.1";
        std::string redisPort = "6379";
        int threads = 20;
        std::string redisStreamKey = "test-topic";

        if (argc == 5)
        {
            redisHost = argv[1];
            redisPort = static_cast<unsigned short>(std::atoi(argv[2]));
            threads = std::max<int>(1, std::atoi(argv[3]));
            redisStreamKey = argv[4];
        }

        net::io_context ioc;

        std::cout << "[" << std::this_thread::get_id() << "] Starting redis client on " << redisHost << ":" << redisPort << std::endl;

        auto redisClient = std::make_shared<redis_client>(
            ioc,
            redis::address{redisHost, redisPort},
            redisStreamKey);

        redisClient->start();

        // Run the I/O service on the requested number of threads
        std::vector<std::thread> v;
        v.reserve(threads - 1);
        for(auto i = threads - 1; i > 0; --i) {
            v.emplace_back(
            [&ioc] {
                ioc.run();
            });
        }
        ioc.run();

        return 0;
    }
    catch (std::exception const &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 1;
}