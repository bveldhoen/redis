/* Copyright (c) 2018-2022 Marcelo Zimbres Silva (mzimbres@gmail.com)
 *
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE.txt)
 */

#include <iostream>
#include <boost/asio.hpp>
#include <boost/redis.hpp>
#include <boost/redis/src.hpp>

#include <memory>
#include <string>
#include <thread>
#include <vector>

namespace net = boost::asio;

namespace redis = boost::redis;
using redis::operation;
using redis::request;
using boost::redis::generic_response;

void log(boost::system::error_code const& ec, char const* prefix)
{
   std::clog << prefix << ec.message() << std::endl;
}

class redis_client
{
    redis::connection conn_;
    redis::address addr_;
    std::string redisStreamKey_;
    std::string streamId_;
    redis::request req_;
    redis::generic_response resp_;

public:
    redis_client(
        net::io_context& ioc,
        const redis::address& addr,
        const std::string& redisStreamKey)
        : conn_(net::make_strand(ioc))
        , addr_(addr)
        , redisStreamKey_(redisStreamKey)
        , streamId_("$")
        , req_()
        , resp_()
    {
    }

    void start()
    {
       std::chrono::seconds timeout{10};

       redis::async_run(conn_, addr_, timeout, timeout, [this](auto ec) {
          log(ec, "async_run: ");
       });

       do_exec();
    }

private:

    void
    on_run(
        boost::system::error_code ec)
    {
        if (ec) {
            return log(ec, "on_run: ");
        }
    }

    void
    on_connect(
        const boost::system::error_code& ec,
        auto ep)
    {
        if (ec) {
            return log(ec, "on_connect: ");
        }

        conn_.async_run([this](auto ec) { this->on_run(ec); });
        do_exec();
    }

    void
    do_exec()
    {
        req_.clear();
        req_.push("XREAD", "BLOCK", "0", "STREAMS", this->redisStreamKey_, this->streamId_);

        conn_.async_exec(
            req_,
            resp_,
            [this](auto ec, auto size) { this->on_exec(ec, size); });
    }

    void on_exec(
        boost::system::error_code ec,
        std::size_t responseSize)
    {
        try {
            this->on_exec_internal(ec, responseSize);
        }
        catch (...) {
        }

        do_exec();
    }

    void
    on_exec_internal(
        boost::system::error_code ec,
        std::size_t responseSize)
    {
        static const std::string Response_Field_MyField = "myfield";

        if (ec)
        {
            log(ec, "on_exec: ");
            conn_.cancel(operation::run);
            return;
        }

        if (!resp_.has_value())
        {
            return;
        }

        // std::cout << "Response: ";
        // for (int i = 0; i < resp->value().size(); ++i) {
        //     std::cout << resp->value().at(i).value << ", ";
        // }
        // std::cout << std::endl;

        // The following approach was taken in order to be able to deal with the responses,
        //  as generated by redis in the case that there are multiple stream 'records' within a single generic_response.
        //  The nesting and number of values in localResp->value() are different, depending on the contents of the stream in redis.
        //  Uncomment the above commented-out code for examples while running the XADD command.

        // "myfield" values don't start before index 4.
        std::size_t itemIndex = 4;
        while (itemIndex < resp_.value().size()) {
            const auto& val = resp_.value().at(itemIndex).value;

            if (Response_Field_MyField.compare(val) == 0) {
                // We've hit a myfield field.
                //  The streamId is located at itemIndex - 2
                //  The payload is located at itemIndex + 1
                this->streamId_ = resp_.value().at(itemIndex - 2).value;
                std::cout << "[" << std::this_thread::get_id() << "] StreamId: " << this->streamId_ << ", MyField: " << resp_.value().at(itemIndex + 1).value << std::endl;
                ++itemIndex; // We can increase so we don't read this again
            }

            ++itemIndex;
        }
    }
};

std::shared_ptr<redis_client> startRedisClient(
    const std::string& ipAddress,
    const std::string& portNumber,
    const std::string& redisStreamKey,
    boost::asio::io_context& ioc)
{
    auto const address = net::ip::make_address(ipAddress);

    auto redisClient = std::make_shared<redis_client>(
        ioc,
        redis::address{ipAddress, portNumber},
        redisStreamKey);
    redisClient->start();
    return redisClient;
}

// Run this in another terminal:
//  redis-cli -r 100000 -i 0.0001 XADD "test-topic" "*" "myfield" "myfieldvalue1"
auto main(int argc, char * argv[]) -> int
{
    try {
        std::string redisHost = "127.0.0.1";
        std::string redisPort = "6379";
        int threads = 20;
        std::string redisStreamKey = "test-topic";

        if (argc == 5)
        {
            redisHost = argv[1];
            redisPort = argv[2];
            threads = std::max<int>(1, std::atoi(argv[3]));
            redisStreamKey = argv[4];
        }

        net::io_context ioc;

        std::cout << "[" << std::this_thread::get_id() << "] Starting redis client on " << redisHost << ":" << redisPort << std::endl;
        auto redisClient = startRedisClient(redisHost, redisPort, redisStreamKey, ioc);

        // Run the I/O service on the requested number of threads
        std::vector<std::thread> v;
        v.reserve(threads - 1);
        for(auto i = threads - 1; i > 0; --i) {
            v.emplace_back(
            [&ioc] {
                ioc.run();
            });
        }
        ioc.run();

        return 0;
    }
    catch (std::exception const &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 1;
}
